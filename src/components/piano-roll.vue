<template lang="pug">
.d-flex.flex-grow-1(:class="ltr?'flex-column':''" style="user-select:none" :style="{cursor}")

	.d-flex.flex-shrink-0.bg-dark(:class="ltr?'':'flex-column-reverse'")
		.btn.btn-dark.p-0(:style="{flex:`0 0 ${grid.whiteKey}px`,writingMode:ltr?'horizontal-tb':'vertical-lr'}" @click="toggleDisplay()") {{ltr?'編輯':'練琴'}}
		.flex-grow-1.position-relative.overflow-hidden(ref="ticks" @wheel="scaleX($event)" @mousedown="ticking=true;handleMove($event)")
			.position-absolute.text-light.text-right(v-for="tick,ti in ticks" :key="ti" :style="tick.style") {{tick.content}}
			i.fa.position-absolute.text-warning(v-if="!freezeScroll" :class="ltr?'fa-chevron-down':'fa-chevron-right'" 
				:style="ltr?{...cursorStyle,marginLeft:'-6px'}:{...cursorStyle,marginBottom:'-6px'}")
					
	.d-flex.flex-grow-1.bg-dark(:class="ltr?'':'flex-column-reverse'" @contextmenu.prevent="")
		.flex-shrink-0.position-relative.overflow-hidden(@wheel="scaleY($event)" :style="ltr?{width:grid.whiteKey+'px'}:{height:grid.whiteKey+'px'}")
			.position-absolute.text-dark(v-for="pG,pi in pianoGrids" :key="pi" :style="pG.style" :class="pG.class" @mousedown="pianoStart(grid2midi(pi))") {{pG.content}}
			
		.flex-grow-1.position-relative.overflow-hidden(ref="scroller" @wheel="handleWheel($event)" @mousedown="handleStart($event)")
			canvas.w-100.h-100.position-absolute(ref="canvas")
			//- template(v-for="track in scrollerTracks")
				transition-group(name="fade")
					small.position-absolute.text-center(v-for="note in track.notes" :key="note.i" :style="noteStyle(note,track)") {{note.l*grid.W>30&&grid.H>14?grid2note(note.y):''}}
			.position-absolute(:style="rangeStyle") 
			.position-absolute.border.border-warning(v-if="!freezeScroll" :class="ltr?'h-100':'w-100'" :style="cursorStyle")
			transition-group(name="fade")
				.position-absolute.h-100(v-if="!ltr" v-for="note in triggering" :key="'trig'+note.i" :style="trigStyle(note)")

	.d-flex.flex-shrink-0.bg-dark(:class="ltr?'':'flex-column-reverse'")
		.overflow-auto.hide-scrollbar(:style="{flex:`0 0 ${grid.whiteKey}px`,maxHeight:grid.velH+grid.sliderSize+'px'}")
			.small.text-center(v-for="val,name in chords" :key="name" @click="chordType=name" 
				:class="chordType==name?'text-light bg-secondary':'text-muted bg-dark'") {{name}}
		.flex-grow-1.position-relative.overflow-hidden
			//- .position-relative(ref="velocities" :style="ltr?{width:'100%',height:grid.velH+'px'}:{height:'100%',width:grid.velH+'px'}" @mousedown="velociting=true;setVelocity($event)")
				template(v-for="track in scrollerTracks")
					.position-absolute(v-for="note in track.notes" :key="note.i" :style="velStyle(note,track)")
			Scrollbar.position-absolute(:style="ltr?{left:0,bottom:0}:{right:0,top:0}" :clientSize="scrollBound.clientSize" :scrollSize="scrollSize" v-model="scrollLeft" :sliderSize="grid.sliderSize" :ltr="ltr")
</template>

<script>
import Scrollbar from './scrollbar.vue'
export default {
	name: 'piano-roll',
	components: {Scrollbar},
	data:()=>({
		// width height  八度 小節
		grid: {W:20,H:20,octave:8,beat:8,velH:60, velSize:4,blackKey:30,whiteKey:60,sliderSize:16},
		ltr: false, metronome: false, scrollTop:0, scrollLeft: 0,
		lastNote: {a:false,x:0,y:0,l:1,f:440,v:30},
		// active grid-x grid-y length frequency velocity delay
		chordType: 'mono',
		chords: {
			mono: [0],
			major: [0,4,7],
			minor: [0,3,7],
			major7: [0,4,7,11],
			minor7: [0,3,7,10],
		},
		activeNotes: [], clipboard: [], 
		dragging: null, //拖曳中的音符
		ticking: false, // 調整時間軸
		recording: false, // 錄音中
		velociting: false, // 調整力度
		resizing: false, // 調整音符長短
		resizeBuffer: 6,
		playing: false, // 正在播放
		range: {sx:0,sy:0,ex:0,ey:0}, // 正在選取範圍
		ranging: false, 
		cursor: 'auto', // css鼠標
		mouse: {button:-1,x:0,y:0,clientX:0,clientY:0},
		deleting: false, // 正在按右鍵刪除
		ctrlKey: false, shiftKey: false,
		triggering: [], // 以觸發的音訊
		playX: -1, lastX: -1, floatX: 0,
		playTimeout: null, freezeScroll: false,
		historyIdx:0, histories: [],
		events: {},
	}),
	props:{
		bpm: {type:Number,default:128},
		tracks: {type:Array,default:()=>([])},
		trackIndex: {type:Number,default:128},
	},
	methods:{
		// utils
		minmax(input,min,max){return input>max?max:input<min?min:input},
		generateID(){
			return '_' + Math.random().toString(36).slice(2)
		},
		grid2note(y){
			let {octave} = this.grid
			let notes = ['B','A#','A','G#','G','F#','F','E','D#','D','C#','C']
			let note = notes[y%12]+Math.floor((octave*12-y-1)/12)
			return note
		},
		midi2grid(midi){return this.grid.octave*12-midi+11},
		grid2midi(y){return this.grid.octave*12-y+11},
		grid2freq(y){
			let midi = this.grid2midi(y)
			let freq = 440*Math.pow(2,(midi-69)/12)
			return Math.round(freq)
		},
		getGrid(cx,cy){
			let {top,left,right,bottom} = this.$refs['scroller'].getBoundingClientRect()
			let {W,H,octave} = this.grid
			if(this.ltr){
				let rx = cx-left+this.scrollLeft
				let ry = cy-top+this.scrollTop
				let x = Math.floor(rx/W)
				let y = Math.floor(ry/H)
				return {x,y,rx,ry}
			}else{
				let rx = this.scrollLeft-cy+bottom
				let ry = right-cx-this.scrollTop
				let x = Math.floor(rx/W)
				let y = Math.floor(ry/H)
				return {x,y,rx,ry}
			}
		},
		checkMovable(dx,dy){
			let {octave,beat} = this.grid
			let xs = this.activeNotes.map(n=>n.x+dx).every(x=>0<=x)
			let ys = this.activeNotes.map(n=>n.y+dy).every(y=>0<=y&&y<octave*12)
			return xs&&ys
		},
		// mouse-events
		scaleX(e,arg){
			e.preventDefault()
			let delta = Math.sign(e.deltaY)*2
			this.grid.W = this.minmax(this.grid.W-delta,5,25)
		},
		scaleY(e,arg){
			e.preventDefault()
			let delta = Math.sign(e.deltaY)*2
			this.grid.H = this.minmax(this.grid.H-delta,10,30)
		},
		handleWheel(e){
			let {W,H,beat} = this.grid
			if(this.ltr){
				if(this.shiftKey) 
					if(this.freezeScroll&&this.playing) return
					else this.scrollLeft+= Math.sign(e.deltaY)*W*beat
				else this.scrollTop+= Math.sign(e.deltaY)*H*4
			}else{
				if(this.shiftKey) this.scrollTop+= Math.sign(e.deltaY)*H*4
				else 
					if(this.freezeScroll&&this.playing) return
					else this.scrollLeft-= Math.sign(e.deltaY)*W*beat
			}
		},
		resizeStart(dir,note){
			if(!this.activeNotes.includes(note))
				this.activeNotes = [note]
			this.resizing = {dir,note}
		},
		setVelocity(e){
			let {x} = this.getGrid(e.clientX,e.clientY)
			let {velH,velSize} = this.grid
			let {top,left} = this.$refs['velocities'].getBoundingClientRect()
			let px = this.ltr?e.clientY-top:e.clientX-left
			let velocity = 127-this.minmax(parseInt(px/(velH-velSize)*127),0,127)
			let notes = this.activeNotes.length?this.activeNotes:this.notes
			notes.filter(n=>n.x<=x&&x<n.x+n.l)
				.filter(n=>!this.triggering.includes(n))
				.map(n=>n.v=velocity)
		},
		handleStart(e){
			let {x,y,rx,ry} = this.getGrid(e.clientX,e.clientY)
			let { W } = this.grid
			let notes = this.notes.filter(n=>n.y==y).filter(n=>n.x<=x&&x<n.x+n.l)
			this.mouse = {button:e.button,x,y,clientX:e.clientX,clientY:e.clientY}
			if(e.button==0){
				if(this.ctrlKey){
					this.clearSelection()
					this.ranging = true
					this.range.sx = x
					this.range.sy = y
				}else if(notes.length){
					this.addHistory()
					// detect if in resize area
					let note = notes[0]
					let dx = rx-note.x*W
					if(dx<this.resizeBuffer)
						this.resizing = {dir:'left',note}
					else if(dx>note.l*W-this.resizeBuffer)
						this.resizing = {dir:'right',note}
					if(!this.activeNotes.includes(note)){
						this.clearSelection()
						note.a = true
						this.activeNotes = [note]
					}
					// move the note
					if(!this.resizing){
						this.dragging = note
						this.triggerSelection(false)
					}
				}else{
					this.activeNotes.map(n=>{n.a=false})
					this.activeNotes = []
					this.addHistory()
					for(let oy of this.chords[this.chordType]){
						let newNote = {
							i:this.generateID(),
							a:true, x,
							y: y - oy,
							l:this.lastNote.l,
							f:this.grid2freq(y-oy),
							v:this.lastNote.v,
						}
						this.dragging = newNote
						this.notes.push(newNote)
						this.activeNotes.push(newNote)
					}
					this.triggerSelection(false)
				}
			}else if(e.button==2){
				this.clearSelection()
				this.deleting = true
				if(notes.length){
					this.addHistory()                    
					this.notes.splice(this.notes.findIndex(n=>n==notes[0]), 1)
				}
			}
		},
		handleMove(e){
			if(this.velociting) return this.setVelocity(e)
			let {x,y,rx,ry} = this.getGrid(e.clientX,e.clientY)
			let notes = this.notes.filter(n=>n.y==y).filter(n=>n.x<=x&&x<n.x+n.l)
			if(this.ticking){
				this.playX = this.lastX = this.floatX = x
				// this.cursor = 'col-resize'
			}else if(this.ranging){
				this.range.ex = x
				this.range.ey = y
			}else if(this.resizing){
				let {dir,note} = this.resizing
				let dx = x - note.x
				let dl = x-note.x-note.l+1
				if(dir=='left'&&this.activeNotes.every(n=>n.x+dx<n.x+n.l)){
					for(let n of this.activeNotes){
						n.l-= dx
						n.x+= dx
					}
				}else if(dir=='right'&&this.activeNotes.every(n=>n.l+dl>0)){
					for(let n of this.activeNotes) n.l+= dl
				}
			}else if (this.dragging){
				let dx = x-this.mouse.x
				let dy = y-this.mouse.y
				if(this.checkMovable(dx,dy)){
					for(let note of this.activeNotes){
						note.x += dx
						note.y += dy
						if(dy!=0){
							this.triggerRelease(note)
							note.f = this.grid2freq(note.y)
						}
					}
				}
			}else if(notes.length){
				// detect if in resize zone, and set cursor style
				let notes = this.notes.filter(n=>n.x<=x&&x<n.x+n.l).filter(n=>n.y==y)
				let {W} = this.grid
				let dx = rx-notes[0].x*W
				if(this.deleting){
					this.addHistory()
					this.notes.splice(this.notes.findIndex(n=>n==notes[0]), 1)
				}else if(this.velociting){
					this.cursor = this.ltr?'ns-resize':'ew-resize'
				}else if(dx<this.resizeBuffer||dx>notes[0].l*W-this.resizeBuffer||this.resizing)
					this.cursor = this.ltr?'ew-resize':'ns-resize'
				else
					this.cursor = 'auto'
			}else if(this.mouse.button==1) {
				this.scrollLeft -= this.ltr?e.clientX-this.mouse.clientX:this.mouse.clientY-e.clientY
				this.scrollTop -= this.ltr?e.clientY-this.mouse.clientY:e.clientX-this.mouse.clientX
				this.cursor = 'grabbing'
			}else {
				this.cursor = 'auto'
			}
			this.mouse.x = x
			this.mouse.y = y
			this.mouse.clientX = e.clientX
			this.mouse.clientY = e.clientY
		},
		handleEnd(e){
			if(this.recording){
				for(let note in this.activeNotes)
					this.pianoEnd(this.grid2midi(note.y))
			}else if(this.ranging){
				let {sx,sy,ex,ey} = this.range
				if(ex<sx) sx = [ex,ex=sx][0]
				if(ey<sy) sy = [ey,ey=sy][0]
				this.activeNotes = this.notes.filter(n=>{
					return n.x<=ex&&sx<n.x+n.l&&sy<=n.y&&n.y<=ey
				})
				this.activeNotes.map(n=>{n.a=true})
				this.ranging = false
			}else if(this.resizing){
				this.lastNote = {...this.resizing.note}
				this.resizing = false
			}else if(this.activeNotes.length){
				this.lastNote = {...this.activeNotes[0]}
				this.dragging = false
				this.activeNotes.map(n=>{
					this.triggerRelease(n)
					n.f = this.grid2freq(n.y)
				})
			}else{
				for(let note in this.triggering)
					this.pianoEnd(this.grid2midi(note.y))
			}
			this.deleting = false
			this.velociting = false
			this.mouse.button = -1
			this.ticking = false
		},
		// commands
		playLoop(){
			let {W,beat} = this.grid
			if(this.freezeScroll) this.scrollLeft = this.floatX*this.grid.W
			// async
			let interpolate =  Math.min(this.beatSec*30) //FPS
			clearTimeout(this.playTimeout)
			if(this.playX>this.endX) return this.stop()
			else this.playTimeout = setTimeout(()=>{ this.floatX+=1/interpolate; this.playLoop() }, 1000*this.beatSec/interpolate)
			if(Math.floor(this.floatX)-this.playX>=1) this.playX++
			else return //非跨越整數，略過下列執行
			// time consuming process
			if(this.recording){
				for(let note of this.activeNotes) note.l = this.playX - note.x
				this.$emit('mic-sample')
			}else{
				for(let track of this.tracks){
					for(let note of track.notes){
						if(!note.p&&note.x==this.playX){
							let duration = note.l*this.beatSec
							track.instrument.triggerAttackRelease(note.f,duration,undefined,note.v/127)
							note.p = true
							this.triggering.push(note)
						}
					}
					for(let note of this.triggering){
						if(note.p&&note.x+note.l<this.playX){
							note.p = false
							this.triggering = this.triggering.filter(n=>n!=note)
						}
					}
				}
			}
			// emit metronome
			if(this.metronome&&this.playX%beat==0) this.$emit('metronome',this.playX%(beat*4)==0?'F5':'F4')
		},
		record(){
			for(let note of this.activeNotes)
				note.a = false
			if(this.metronome) this.playX = this.lastX-16
			this.activeNotes = []
			this.recording = true
			this.play()
		},
		play(){
			if(this.playing) return
			this.playing = true
			if(this.freezeScroll) this.playX = this.floatX = this.scrollBound.minX
			this.playLoop()
		},
		stop(){
			this.playing = false
			this.recording = false
			this.floatX = this.playX
			this.playX = this.lastX
			clearTimeout(this.playTimeout)     
			for(let note of this.triggering)
				this.triggerRelease(note)
		},
		randomVelocity(){
			this.notes.filter(n=>!this.triggering.includes(n))
				.map(n=>n.v=Math.round(Math.random()*100+27))
		},
		async toggleDisplay(){
			this.ltr=!this.ltr
			this.grid.H=20;
			await this.$nextTick();
		},
		triggerAttack(note){
			this.instrument.triggerAttack(note.f,undefined,note.v/127)
			this.triggering.push(note)
		},
		triggerRelease(note){
			this.instrument.triggerRelease(note.f)
			this.triggering =  this.triggering.filter(n=>n!=note)
		},
		triggerSelection(shouldRelease=true){
			if(!this.activeNotes.length) return
			let firstNote = this.activeNotes[0]
			if(!this.activeNotes.every(n=>n.x==firstNote.x)) return
			for(let note of this.activeNotes){
				if(shouldRelease)
					this.instrument.triggerAttackRelease(note.f,'8n',undefined,note.v/127)
				else
					this.triggerAttack(note)
			}
		},
		clearSelection(){
			this.activeNotes.map(n=>{n.a=false})
			this.activeNotes = []
		},
		pianoStart(midi,v=60){
			let y = this.midi2grid(midi)
			let newNote = {
				i:this.generateID(),
				a:true,
				x:this.playX-1,
				y:y,
				l:1,
				f:this.grid2freq(y),
				v:v,
				p:false, //playing
			}
			this.activeNotes.push(newNote)
			if(this.recording)
				this.notes.push(newNote)
			this.triggerAttack(newNote)
		},
		pianoEnd(midi){
			let y = this.midi2grid(midi)
			if(this.recording){
				let idx = this.activeNotes.findIndex(n=>n.y==y)
				if(idx==-1) return
				let note = this.activeNotes[idx]
				note.a = false
				this.triggerRelease(note)
				this.activeNotes.splice(idx,1)
			}else{
				let idx = this.triggering.findIndex(n=>n.y==y)
				if(idx==-1) return
				let note = this.triggering[idx]
				this.triggerRelease(note)
			}
		},
		copyNotes(){
			this.clipboard = JSON.parse(JSON.stringify(this.activeNotes))
		},
		pasteNotes(){
			this.addHistory()
			let minX = Math.min(...this.clipboard.map(n=>n.x))
			let startX = this.mouse.x
			let cloned = JSON.parse(JSON.stringify(this.clipboard))
			this.activeNotes.map(n=>{n.a=false})
			cloned.map(n=>{
				n.i = this.generateID()
				n.x+=startX-minX
			})
			this.notes.push(...cloned)
			this.activeNotes = cloned
		},
		deleteNotes(){
			this.addHistory()
			let indexArr = []
			this.$emit('notes', this.notes.filter(n=>!this.activeNotes.includes(n)))
			this.activeNotes = []
		},
		addHistory(msg=''){
			this.histories[this.historyIdx] = {
				msg, notes: JSON.parse(JSON.stringify(this.notes))
			}
			this.historyIdx++
			this.histories = this.histories.slice(0,this.historyIdx)
		},
		traceHistory(offset){
			if(offset<0&&!this.histories[this.historyIdx]){
				this.addHistory()
				this.historyIdx--
			}
			this.historyIdx = this.minmax(this.historyIdx+offset,0,this.histories.length-1)
			let {notes} = this.histories[this.historyIdx]
			this.$emit('notes', notes)
			this.activeNotes = notes.filter(n=>n.a)
		},
	// key-events
		handleKeydown(e){
			switch(e.key.toUpperCase()){
				case 'SHIFT':
					this.shiftKey = true; break
				case 'CONTROL':
					this.ctrlKey = true; break
				case ' ':
					e.preventDefault()
					if(this.playing) this.stop()
					else this.play()
					break
				case 'A':
					if(e.ctrlKey){
						this.activeNotes = this.notes
						this.activeNotes.map(n=>{n.a=true})
					}
					break
				case 'X':
					if(e.ctrlKey){
						this.copyNotes()
						this.deleteNotes()
					}
					break
				case 'C': if(e.ctrlKey) this.copyNotes();break
				case 'V': if(e.ctrlKey) this.pasteNotes();break
				case 'F': if(e.ctrlKey) e.preventDefault();this.freezeScroll=!this.freezeScroll;break
				case 'DELETE': this.deleteNotes();break
				case 'BACKSPACE': this.deleteNotes();break
				case 'ARROWLEFT':
					if(e.shiftKey){
						if(this.activeNotes.every(n=>n.l>1))
							this.activeNotes.map(n=>{n.l--})
					}else if(this.checkMovable(-1,0)){
						this.activeNotes.map(n=>{n.x--})
					}
					break
				case 'ARROWRIGHT':
					if(this.checkMovable(1,0)){
						if(e.shiftKey)
							this.activeNotes.map(n=>{n.l++})
						else
							this.activeNotes.map(n=>{n.x++})
					}
					break
				case 'ARROWDOWN':
					if(e.shiftKey&&this.activeNotes.length){
						let minY = Math.min(...this.activeNotes.map(n=>n.y))
						let i = this.activeNotes.findIndex(n=>n.y==minY)
						this.activeNotes[i].y+= 12
						this.triggerSelection()
					}else{
						this.activeNotes.map(n=>{n.y++;n.f=this.grid2freq(n.y)})
					}
					break
				case 'ARROWUP':
					if(e.shiftKey&&this.activeNotes.length){
						let maxY = Math.max(...this.activeNotes.map(n=>n.y))
						let i = this.activeNotes.findIndex(n=>n.y==maxY)
						this.activeNotes[i].y-= 12
						this.triggerSelection()
					}else{
						this.activeNotes.map(n=>{n.y--;n.f=this.grid2freq(n.y)})
					}
					break
				case 'Z':
					if(e.ctrlKey){
						if(e.shiftKey) this.traceHistory(1)
						else this.traceHistory(-1)
					}
					break
				default: break
			}
		},
		handleKeyup(e){
			switch(e.key.toUpperCase()){
				case 'SHIFT': this.shiftKey = false; break
				case 'CONTROL': this.ctrlKey = false; break
				default: break;
			}
		},
		// styles
		velStyle(note, track){
			let {W,H,velH,velSize} = this.grid
			return this.ltr?{
				bottom:note.v/127*(velH-velSize)+'px',
				left: 0,
				transform: `translateX(${note.x*W-this.scrollLeft}px)`,
				width: note.l*W+'px',
				height: `${velSize}px`,
				background: note.a?'#FFA3A4':'#C4FACF',
			}:{
				right:note.v/127*(velH-velSize)+'px',
				bottom: 0,
				transform: `translateY(${this.scrollLeft-note.x*W}px)`,
				height: note.l*W+'px',
				width: `${velSize}px`,
				background: note.a?'#FFA3A4':'#C4FACF',
			}
		},
		trigStyle(note){
			let { H } = this.grid
			return {
				top:0, width:H+'px', right: H*note.y+this.scrollTop+'px',
				background: 'rgba(255, 193, 7, 0.1)'
			}
		},
		draw(){
			const canvas = this.$refs.canvas
			const ctx = canvas.getContext('2d')
			let {width, height} = canvas
			let {W,H} = this.grid
			ctx.clearRect(0,0,width,height)
			const res = (m,n)=>(m%n+n)%n
			let iy = Math.floor(this.scrollTop/H)
			let jy = (this.ltr?height:width)/H
			let oy = res(this.scrollTop,H)
			for(let i=-1;i<=jy;i++){
				let isBlack = [2,4,6,9,11].includes(res(iy+i+1,12))
				ctx.fillStyle = isBlack?'#394B56':'#42545F'
				if(this.ltr) ctx.fillRect(0,i*H-oy,width,H-2)
				else ctx.fillRect((i+1)*H-oy,0,H-2,height)
			}
			let ix = Math.floor(this.scrollLeft/W)
			let jx = (this.ltr?width:height)/W
			let ox = res(this.scrollLeft,W)
			for(let i=-1;i<=jx;i++){
				ctx.fillStyle = res(ix+i+1,4)?'#42545F':'#29373F'
				if(this.ltr) ctx.fillRect(i*W-ox,0,1,height)
				else ctx.fillRect(0,height-(i+1)*W+ox,width,1)
			}
			for(let track of this.scrollerTracks){
				for(let note of track.notes){
					let [r,g,b] = track.rgb
					let alpha = (note.v/127)*0.5+0.5
					let activeColor = `rgba(255, 163, 164, ${alpha})`
					let bgc = note.a?activeColor:`rgba(${r}, ${g}, ${b}, ${alpha})`
					ctx.fillStyle = bgc
					if(this.ltr) ctx.fillRect(
						note.x*W-this.scrollLeft, 
						note.y*H-this.scrollTop, 
						note.l*W, H)
					else ctx.fillRect(
						width-(note.y+1)*H-this.scrollTop, 
						height-(note.x+1)*W+this.scrollLeft-note.l*W, 
						H, note.l*W)
				}
			}
			requestAnimationFrame(this.draw)
		},
	},
	computed:{
		notes(){
			return this.tracks[this.trackIndex]?this.tracks[this.trackIndex].notes:[]
		},
		instrument(){
			return this.tracks[this.trackIndex].instrument
		},
		scrollBound(){
			let {clientWidth,clientHeight} = this.$refs['scroller']??{}
			let clientSize = this.ltr?clientWidth:clientHeight
			let { W } = this.grid
			let minX = Math.floor(this.scrollLeft/W)
			let maxX = Math.ceil((this.scrollLeft+clientSize)/W)
			return {minX, maxX, clientSize}
		},
		scrollerTracks(){
			let {minX, maxX} = this.scrollBound
			return this.tracks.map(track=>({
				...track,
				notes: track.notes.filter(n=>minX<=n.x+n.l&&n.x<=maxX)
			}))
		},
		ticks(){
			let {minX, maxX} = this.scrollBound
			let {W,beat} = this.grid
			let min = Math.floor(minX/beat), max = Math.ceil(maxX/beat)
			let ticks = []
			for (let i = min; i <=max; i++) 
				ticks.push({
					style: this.ltr?{ 
						width: W*beat+'px', height: '100%', top: 0, left: 0,
						transform: `translateX(${i*W*beat-this.scrollLeft}px)`,
					}:{ 
						height: W*beat+'px', width: '100%', bottom: 0, left: 0,
						transform: `translateY(${this.scrollLeft-i*W*beat}px)`,
					},
					content: i+1
				})
			return ticks
		},
		beatSec(){
			let {beat} = this.grid
			let sec = 60/this.bpm/beat
			let floatPoint = 1e3
			return Math.round(sec*floatPoint)/floatPoint
		},
		endX(){
			let {beat} = this.grid
			let endX = Math.max(...this.tracks.flatMap(track=>track.notes.map(n=>n.x+n.l)))
			endX = Math.ceil(endX/beat)*beat+1
			return endX
		},
		scrollSize(){
			let {clientSize} = this.scrollBound
			let {W} = this.grid
			return clientSize+Math.max(this.scrollLeft, Math.ceil(this.endX*W))
		},
		cursorStyle(){
			let {W} = this.grid
			let duration = this.playing?this.beatSec:0
			return this.ltr?{
				top: 0, left: 0, 
				transform: `translateX(${W*this.playX-this.scrollLeft}px)`,
				transition: `transform ${this.playing?this.beatSec:0}s linear`,
			}:{
				bottom: 0, left: 0,
				transform: `translateY(${this.scrollLeft-W*this.playX}px)`,
				transition: `transform ${this.playing?this.beatSec:0}s linear`,
			}
		},
		rangeStyle(){
			let {sx,sy,ex,ey} = this.range
			if(ex<sx) sx = [ex,ex=sx][0]
			if(ey<sy) sy = [ey,ey=sy][0]
			let {W,H} = this.grid
			return this.ranging?this.ltr?{
				position: 'absolute',
				top: sy*H-this.scrollTop+'px',
				left: sx*W-this.scrollLeft+'px',
				height: (ey-sy)*H+'px',
				width: (ex-sx)*W+'px',
				border: '5px dashed dodgerblue'
			}:{
				position: 'absolute',
				right: sy*H+this.scrollTop+'px',
				bottom: sx*W-this.scrollLeft+'px',
				width: (ey-sy)*H+'px',
				height: (ex-sx)*W+'px',
				border: '5px dashed dodgerblue'
			}:{
				display: 'none'
			}
		},
		pianoGrids(){
			let {H,whiteKey,blackKey,octave} = this.grid
			let blacks = [1,3,5,8,10]
			let top = 0
			let len = octave*12
			return Array.from(Array(len).keys(),i=>{
				let isBlack = blacks.includes(i%12)
				let height = isBlack?H:i%12<7?H*7/4:H*5/3
				if(i>0&&!isBlack) top+= height
				let freq = this.grid2freq(i)
				let isTriggered = this.triggering.some(n=>n.f==freq)
				return this.ltr?{
					class: isTriggered?'bg-warning':isBlack?'bg-dark':'bg-light',
					style:{
						width: (isBlack?blackKey:whiteKey)+'px',
						top: (isBlack?top+H:top)-this.scrollTop+'px',
						left: 0,
						zIndex: isBlack?666:66,
						boxShadow: isBlack?'2px 0 white':'0 -2px black',
						height: height+'px',
						lineHeight: height+'px',
						textAlign: isBlack?'left':'right',
						padding: '0px 4px',
					},
					content: isBlack?'':this.grid2note(i)
				}:{
					class: isTriggered?'bg-warning':isBlack?'bg-dark':'bg-light',
					style:{
						height: (isBlack?blackKey+10:whiteKey)+'px',
						right: (isBlack?H*i:top)+this.scrollTop+'px',
						top: 0,
						zIndex: isBlack?666:66,
						boxShadow: isBlack?'':'2px 0 black',
						width: height+'px',
					},
					content: ''
				}
			})
		},
	},
	mounted(){
		this.addHistory()
		const resizeObserver = new ResizeObserver(entries=>{
			let {width, height} = entries[0].contentRect
			this.$refs.canvas.width = width
			this.$refs.canvas.height = height
		})
		resizeObserver.observe(this.$refs.canvas)
		this.$refs.canvas.width = this.$refs.canvas.clientWidth
		this.$refs.canvas.height = this.$refs.canvas.clientHeight
		this.draw()
		this.ltr = true // 觸發scrollerTracks
		this.events = {
			mousemove: e=>this.handleMove(e),
			mouseup: e=>this.handleEnd(e),
			mouseleave: e=>this.handleEnd(e),
			keydown: e=>this.handleKeydown(e),
			keyup: e=>this.handleKeyup(e),
		}
		for(let name in this.events)
			window.addEventListener(name,this.events[name])
	},
	beforeDestroy(){
		for(let name in this.events)
			window.removeEventListener(name,this.events[name])
	},
}
</script>

<style scoped>
.hide-scrollbar::-webkit-scrollbar {
  	display: none;
}
.hide-scrollbar {
	-ms-overflow-style: none;  /* IE and Edge */
	scrollbar-width: none;  /* Firefox */
}
/* .fade-enter-active{
	opacity: 0.6;
	transition: opacity 0.1s ease-in;
} */
.fade-leave-active {
	transition: opacity 0.3s;
}
.fade-leave-to{
	opacity: 0;
}
</style>